// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_sessions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const newUserSession = `-- name: NewUserSession :exec
INSERT INTO notes.user_sessions (user_id, last_token)
    VALUES ($1, $2)
ON CONFLICT (user_id)
    DO UPDATE SET
        last_token = $2
`

type NewUserSessionParams struct {
	UserID    pgtype.UUID
	LastToken pgtype.Text
}

func (q *Queries) NewUserSession(ctx context.Context, arg NewUserSessionParams) error {
	_, err := q.db.Exec(ctx, newUserSession, arg.UserID, arg.LastToken)
	return err
}

const upsertUserBySub = `-- name: UpsertUserBySub :one
INSERT INTO notes.users (auth0_sub)
    VALUES ($1)
ON CONFLICT (auth0_sub)
    DO UPDATE SET
        auth0_sub = EXCLUDED.auth0_sub
    RETURNING
        id
`

func (q *Queries) UpsertUserBySub(ctx context.Context, auth0Sub pgtype.Text) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertUserBySub, auth0Sub)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
